<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>查找 | xljのblog</title><meta name="author" content="xlj"><meta name="copyright" content="xlj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="查找 之前的内容已经介绍了关于线性、树形和网状的数据结构，本章介绍数据结构的重要操作：查找 基本概念  数据表：数据元素的有限集合 关键字：在数据表中可以最为查找排序的数据元素 查找：根据给定数据元素查找其在数据表中的位置 静态查找表和动态查找表：查找的数据不在数据表中，根据之后是否会将该元素插入到数据表中来判断是动态查找表还是静态查找表 查找效率：衡量指标,平均查找长度（ASL)，含义是关键字比">
<meta property="og:type" content="article">
<meta property="og:title" content="查找">
<meta property="og:url" content="http://example.com/2022/05/16/%E6%9F%A5%E6%89%BE/index.html">
<meta property="og:site_name" content="xljのblog">
<meta property="og:description" content="查找 之前的内容已经介绍了关于线性、树形和网状的数据结构，本章介绍数据结构的重要操作：查找 基本概念  数据表：数据元素的有限集合 关键字：在数据表中可以最为查找排序的数据元素 查找：根据给定数据元素查找其在数据表中的位置 静态查找表和动态查找表：查找的数据不在数据表中，根据之后是否会将该元素插入到数据表中来判断是动态查找表还是静态查找表 查找效率：衡量指标,平均查找长度（ASL)，含义是关键字比">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/article_picture1.png">
<meta property="article:published_time" content="2022-05-15T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-18T02:29:56.504Z">
<meta property="article:author" content="xlj">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/article_picture1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/05/16/%E6%9F%A5%E6%89%BE/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '查找',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-18 10:29:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/article_picture1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">xljのblog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">查找</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-15T16:00:00.000Z" title="发表于 2022-05-16 00:00:00">2022-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-18T02:29:56.504Z" title="更新于 2022-05-18 10:29:56">2022-05-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="查找"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>查找</h1>
<p>之前的内容已经介绍了关于线性、树形和网状的数据结构，本章介绍数据结构的重要操作：<strong>查找</strong></p>
<h2 id="基本概念-4">基本概念</h2>
<ul>
<li>数据表：数据元素的有限集合</li>
<li>关键字：在数据表中可以最为查找排序的数据元素</li>
<li>查找：根据给定数据元素查找其在数据表中的位置</li>
<li>静态查找表和动态查找表：查找的数据不在数据表中，根据之后是否会将该元素插入到数据表中来判断是动态查找表还是静态查找表</li>
<li>查找效率：衡量指标,平均查找长度（ASL)，含义是关键字比较次数的数学期望。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>P</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>C</mi><mi>i</mi></msub></mstyle></mrow><annotation encoding="application/x-tex">ASL=\displaystyle\sum_{i=1}^n P_i*C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>装载因子:数据表中装载元素的情况，计算公式<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\alpha=\frac{n}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
<h2 id="顺序表的查找">顺序表的查找</h2>
<p>顺序表的查找有两类：<strong>顺序查找和折半查找</strong></p>
<h3 id="顺序查找：">顺序查找：</h3>
<p>n个元素的表从头查找到尾，边查找边比较<br>
在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>等概率的情况下，平均查找长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">ASL=\frac{n-1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<ul>
<li>如果概率不同，可以从概率较高的一端开始查找，以提高查找效率</li>
<li>同样，如果是按照链式存储的方式存储数据表的，查找方式和顺序表是一致的。</li>
<li>如果顺序表有序，也可以进一步提升查找效率<br>
优点：查找思想简单<br>
缺点：查找的长度较长，在n较大时效率较低</li>
</ul>
<h3 id="有序表的折半查找">有序表的折半查找</h3>
<p>此处强调前提要求必须是<strong>有序</strong></p>
<ol>
<li>折半查找分为三步</li>
</ol>
<ul>
<li>如果区间长度小于1，查找失败，否者继续以下操作</li>
<li>求出区间中间点的下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid=(low+high)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span></li>
<li>将区间中间的数据元素的关键字和查找的数据关键字进行比较
<ul>
<li>elem[mid]==key,查找成功</li>
<li>elem[mid]&lt; key 在左区间进行折半查找</li>
<li>elem[mid]&gt; key 在右区间进行折半查找</li>
</ul>
</li>
</ul>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>, <span class="keyword">class</span> <span class="title">KeyType</span>&gt;</span>   <span class="comment">//递归实现折半查找</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">BinSearch</span><span class="params">(ElemType elem[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, KeyType key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">if</span> (low &gt; high)        mid = <span class="number">-1</span>;           <span class="comment">// 查找失败</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">	mid = (low + high) / <span class="number">2</span>;                <span class="comment">// 计算区间中间位置</span></span><br><span class="line">	<span class="keyword">if</span> (key &lt; elem[mid])</span><br><span class="line">	          mid = <span class="built_in">BinSearch</span>(elem, low, mid - <span class="number">1</span>, key);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; elem[mid])</span><br><span class="line">	          mid = <span class="built_in">BinSearch</span>(elem, mid + <span class="number">1</span>, high, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span>               <span class="comment">//迭代实现折半查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinSearch</span><span class="params">(ElemType elem[], <span class="keyword">int</span> n, ElemType key)</span>  </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low=<span class="number">0</span>, high=n <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)	&#123;</span><br><span class="line"> mid=(low + high) / <span class="number">2</span>;	             <span class="comment">// 计算区间中间位置</span></span><br><span class="line"> <span class="keyword">if</span> (key == elem[mid])  <span class="keyword">return</span> mid;   <span class="comment">// 查找成功</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key &lt;= elem[mid])	high=mid - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span>	low=mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;	                          <span class="comment">// 查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是递归还是迭代实现折半查找，内容其实是类似的。<br>
2. 折半查找性能分析<br>
==<strong>折半查找的性能分析是通过构建二叉查找树来进行的</strong>==<br>
构造方式（递归构造）：<br>
* n=0，空树<br>
* n&lt;&gt;0，每一层的父亲节点是查找区间的中间元素 mid=(n-1)/2<br>
* 扩充的二叉查找树，将所有结点的空指针指向空<br>
一般地，折半查找的比较次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\log_2(n+1)\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)⌉</span></span></span></span><br>
==<strong>折半查找的平均查找长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong>==<br>
3. 折半查找的变形<br>
* 斐波那契查找：折半查找是每次把区间分成等长的两块，而斐波那契查找是将区间分为斐波那契长度的块，平均性能比折半查找好，但是平均查找长度是一样的。<br>
* 插值查找：插值查找的思想和折半查找一样，只是求中点的公式不同<br>
$$mid=low+1+\frac{k-elem[low]}{elem[high]-elem[low]}*(high-low-1) $$</p>
<h2 id="索引顺序表和倒排表查找">索引顺序表和倒排表查找</h2>
<p>索引查找的方式解决的是n比较大的情况下，顺序查找效率较低，内存不够的问题。</p>
<h3 id="索引顺序表">索引顺序表</h3>
<ol>
<li>基本概念<br>
索引顺序表由<strong>主表</strong>和<strong>索引表</strong>组成。<br>
一个索引项对应数据表中一个元素时的索引结构叫做稠密索引(<strong>完全索引</strong>)。<br>
当完全索引表中关键字分块有序存放（n个索引项分为m个块（子表）。可以为完全索引表建立一个二级索引表，在二级索引表中一个索引项对应完全索引表中的一个子表，它记录了相应子表中最大关键字以及该子表在数据区中的起始位置，这种索引被称为<strong>二级索引</strong>。<br>
这几个概念之间的关系图如下：<br>
<img src="/img/article_picture/secondary_index.png"></li>
<li>二级索引查找过程<br>
先在二级索引中查找(确定字表序号）-&gt;在第i个字表中查找-&gt;找到则返回值，找不到则失败。</li>
<li>查找性能分析<br>
索引顺序查找平均长度分为两个部分，<strong>二级索引查找长度和字表查找长度</strong>。<br>
如果使用顺序查找方式，则平均查找长度为:<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>I</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi>S</mi><mi>e</mi><mi>q</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><msup><mi>k</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL_{IndexSeq} = (n+k^2)/(2k)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
如果使用折半查找方式，则平均查找长度为：<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>I</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi>S</mi><mi>e</mi><mi>q</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">ASL_{IndexSeq} = log_2(1+n/k)+k/2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">/2</span></span></span></span></span></p>
</li>
</ol>
<h3 id="倒排索引表">倒排索引表</h3>
<p>如果把一些在查找时经常用到的属性设定为次关键字，并以每一个属性作为次关键字建立次索引表，称为<strong>倒排索引表</strong>。简言之，就是建立一个关于次关键字的表，使得查找时更加方便。<br>
链式倒排索引表结构图如下：<br>
<img src="/img/article_picture/inverted_table_structure.png"><br>
单元式倒排索引表例子：<br>
<img src="/img/article_picture/unit_inverted_table.png"></p>
<h2 id="二叉排序树">二叉排序树</h2>
<h3 id="概念">概念</h3>
<p>二叉排序树是一棵中序排列为顺序的树，根节点的左子树所有结点小于根节点，右子树所有结点大于根节点，左右子树都是二叉排序树（递归）。</p>
<h3 id="二叉排序树的查找">二叉排序树的查找</h3>
<p>查找方式就是从根节点开始比较要查找的关键字的值与结点关键值的值的大小，不断向下查找直至找到结点。代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line">BinTreeNode&lt;ElemType&gt; *BinarySortTree&lt;ElemType&gt;::<span class="built_in">Find</span>(<span class="keyword">const</span> ElemType &amp;key,</span><br><span class="line">	BinTreeNode&lt;ElemType&gt; *&amp;f) <span class="keyword">const</span>&#123;</span><br><span class="line">	BinTreeNode&lt; ElemType&gt; *p=<span class="built_in">GetRoot</span>();</span><br><span class="line">	f=<span class="literal">NULL</span>;		               <span class="comment">//f记录p的双亲</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != key)	&#123;</span><br><span class="line">		<span class="keyword">if</span> (key &lt; p-&gt;data)	&#123;</span><br><span class="line">			f=p;	p=p-&gt;leftChild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>		&#123;</span><br><span class="line">			f=p;	p=p-&gt;rightChild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉排序树的插入">二叉排序树的插入</h3>
<p>要构建一棵二叉排序树，必须有插入结点的操作，二叉排序树的插入方法就是从根节点开始不断比较大小，直到找到可以存放新结点的叶子位置停止。代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BinarySortTree&lt;ElemType&gt;::<span class="built_in">Insert</span>(<span class="keyword">const</span> ElemType &amp;e)&#123;</span><br><span class="line">	BinTreeNode&lt;ElemType&gt; *f;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Find</span>(e, f) == <span class="literal">NULL</span>)	&#123;</span><br><span class="line">		BinTreeNode&lt;ElemType&gt; *p;</span><br><span class="line">		p=<span class="keyword">new</span> BinTreeNode&lt;ElemType&gt;(e);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IsEmpty</span>())	  root=p;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (e &lt; f-&gt;data)	 f-&gt;leftChild=p;</span><br><span class="line">		        <span class="keyword">else</span>	f-&gt;rightChild=p;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了插入操作，我们就可以构建二叉排序树。</p>
<h3 id="二叉排序树的删除">二叉排序树的删除</h3>
<p>有结点插入就一定有结点删除，删除结点要分情况来看：</p>
<ul>
<li>如果被删除的元素是叶子，则只需将其双亲指向它的指针置空，再释放该数据元素的存储空间即可；</li>
<li>如果被删除的元素只有单子树，则可以用它的孩子顶替它的位置，再释放该数据元素的存储空间即可；</li>
<li>如果被删除的元素左、右子树都存在，则:
<ul>
<li>在左(右)子树中寻找最大(小)的元素 （中序遍历中最后一个(第一个)被访问的元素）x</li>
<li>用x的值代替被删除元素的值</li>
<li>删除数据元素x（x没有右(左)子树）<br>
代码实现如下：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ElemType</span>&gt;</span><span class="keyword">void</span> BinarySortTree&lt;ElemType&gt;::<span class="built_in">Delete</span>(BinTreeNode&lt;ElemType&gt; *&amp;p)&#123;</span><br><span class="line">	BinTreeNode&lt;ElemType&gt; *tmpPtr, *tmpF;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;leftChild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rightChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">delete</span> p;	p=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;leftChild == <span class="literal">NULL</span>)	&#123;</span><br><span class="line">		tmpPtr=p;	p=p-&gt;rightChild;	<span class="keyword">delete</span> tmpPtr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;rightChild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		tmpPtr=p;</span><br><span class="line">		p=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">delete</span> tmpPtr;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span>	&#123;	<span class="comment">// p左右子树都存在</span></span><br><span class="line">		tmpF=p;	tmpPtr=p-&gt;leftChild;</span><br><span class="line">		<span class="keyword">while</span> (tmpPtr-&gt;rightChild != <span class="literal">NULL</span>)	&#123;</span><br><span class="line">			tmpF=tmpPtr;</span><br><span class="line">			tmpPtr=tmpPtr-&gt;rightChild;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data=tmpPtr-&gt;data;</span><br><span class="line">		<span class="keyword">if</span> (tmpF-&gt;rightChild == tmpPtr)</span><br><span class="line">			<span class="built_in">Delete</span>(tmpF-&gt;rightChild);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">Delete</span>(tmpF-&gt;leftChild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉排序树查找性能分析">二叉排序树查找性能分析</h3>
<p>二叉排序树是完全二叉树时，其平均查找性能最佳为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> ，与有序表的折半查找相同。当二叉排序树退化为单分支树时，二叉排序树的平均查找性能最差为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>，与顺序表平均查找长度相同。</p>
<h2 id="平衡二叉树">平衡二叉树</h2>
<p>根据二叉排序树的查找性能分析可以看出来，并不是所有的二叉排序树都具备较好的查找性能，而为了提高二叉排序树的查找效率，我们引入了平衡二叉树的概念（本质还是一棵二叉排序树）。这一部分内容主要分为三个部分：定义、平衡旋转（二叉排序如何变为平衡二叉）和平衡二叉的插入删除。</p>
<h3 id="平衡二叉树的定义和概念">平衡二叉树的定义和概念</h3>
<p>平衡因子：树中结点右子树的高度减去左子树的高度所得的高度差<br>
平衡二叉树的任一结点的平衡因子只能取-1、0和1，如果出现平衡因子绝对值大于1的情况，则树不平衡。<br>
只要n个结点的树高度保持在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>,平均查找长度就可以保证在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<h3 id="平衡旋转">==平衡旋转==</h3>
<p>插入删除结点可能导致平衡二叉树不平衡，为了保证平衡性，就有了平衡旋转的操作。对于保证平衡二叉树的平衡性来说，只要针对性地对失衡的最小子树进行平衡旋转即可。平衡操作一共有四种LL,RR,LR,RL旋转。</p>
<h4 id="LL旋转">LL旋转</h4>
<p>在A的左(L)孩子B的左(L)子树上插入新结点，使A的平衡因子由-1变成-2，则进行LL平衡旋转（左边的左边插结点）<br>
从A沿插入路径连续取2个结点A和B，以B为旋转轴，将结点A顺时针向下旋转成为B的右孩子，结点B代替原来结点A的位置，结点B原来的右孩子作为结点A的左孩子。（左边变根节点，原根节点加左右子树为右子树）<br>
操作图如下：<br>
<img src="/img/article_picture/LLtwist.png"></p>
<h4 id="RR旋转">RR旋转</h4>
<p>在A的右®孩子B的右®子树上插入新结点，使A的平衡因子由1变成2，则需要进行RR平衡旋转(右边的右边插结点)<br>
沿插入路径连续取2个结点A和B，以B为旋转轴，将A逆时针向下旋转成为B的左孩子，B代替原来A的位置，B原来的左孩子成为A的右孩子。（右边变根节点，原结点加右左子树为左子树）<br>
操作图如下：<br>
<img src="/img/article_picture/RRtwist.png"></p>
<h4 id="LR旋转">LR旋转</h4>
<p>在A的左(L)孩子B的右®子树上插入新结点，使A的平衡因子由-1变成-2，则需要进行LR平衡旋转(左边的右边插入结点)<br>
先将A的左孩子B的右孩子C向逆时针方向旋转代替B的位置，再以结点C为旋转轴，将结点A向顺时针方向旋转成为C的右孩子，结点C代替原来结点A的位置，结点C原来的左孩子转为结点B的右孩子，结点C原来的右孩子转为结点A的左孩子。（C替代根节点，C的左右子树分配给A,B的左右子树）<br>
操作图如下：<br>
<img src="/img/article_picture/LRtwist.png"></p>
<h4 id="RL旋转">RL旋转</h4>
<p>在A的右®孩子B的左(L)子树上插入新结点，使A的平衡因子由1变成2，则需要进行RL平衡旋转(右边的左边插入结点)<br>
先将A的右孩子B的左孩子C向顺时针方向旋转代替B的位置，再以C为旋转轴，将A向逆时针方向旋转成为C的左孩子，结点C代替原来结点A的位置，结点C原来的左孩子转为结点A的右孩子，结点C原来的右孩子转为结点B的左孩子。（C替代根节点，C的左右子树分配给A,B的右左子树）<br>
操作图如下：<br>
<img src="/img/article_picture/RLtwist.png"></p>
<h3 id="平衡二叉树的插入删除">平衡二叉树的插入删除</h3>
<h4 id="插入">插入</h4>
<p>总体思路：按照排序原则找到要插入的位置，插入后观察是否平衡，不平衡进行平衡旋转。<br>
具体操作：</p>
<ul>
<li>在查找结点x的插入位置的过程中，记下从根结点到插入位置的路径上<strong>离插入位置最近的且平衡因子绝对值为1的结点</strong>，并令指针a指向该结点；如果此路径上不存在平衡因子绝对值为1的结点，则指针a指向根结点。</li>
<li>对于从a结点到x结点的路径上的每一个结点（不包括结点x），根据结点中关键字和x的大小比较修改结点的平衡因子。如果结点关键字大于x，则结点平衡因子减1；否则结点平衡因子加1。（重新计算平衡因子）</li>
<li>如果结点a的平衡因子绝对值为2，则表示二叉排序树失去平衡，再根据结点a及其左右孩子的平衡因子值来确定平衡旋转的类型。</li>
</ul>
<h4 id="删除">==删除==</h4>
<p>删除结点时，如果平衡因子绝对值变为大于1的情况，就要进行树的缩短。具体操作如下：</p>
<ul>
<li>如果被删结点x有左、右孩子，首先查找x在中序下的直接前驱y(或直接后继)，再把y的内容传送给结点x，再删除结点y（y最多有一个孩子）。</li>
<li>对于删除最多有一个孩子的结点x，可以简单地把x的双亲结点中原来指向x的指针改为指到x的孩子结点。如果结点x没有孩子，则其双亲结点的相应指针置为空。</li>
<li>对于从结点x的双亲到根结点的路径上的每一个结点p，当布尔变量shorter的值为true时，根据以下三种不同的情况继续处理，直到布尔变量shorter的值为false时，整个删除算法结束。
<ul>
<li>情况一，当p的平衡因子=0，若其左子树或右子树被缩短（shorter的值为true），则它的平衡因子改为1或-1，由于此时以结点p为根的子树高度未缩短，故shorter变为false。</li>
<li>情况二，p的平衡因子≠0，且其较高的子树被缩短，则p的平衡因子改为0。由于此时以结点p为根的子树高度被缩短，所以shorter仍为true。</li>
<li>结点p的平衡因子不为0，且较矮的子树又被缩短，则在结点p发生不平衡。此时，将进行平衡化旋转来恢复平衡。令结点p的较高子树的根结点为q，则根据结点p和q的平衡因子值，有如下三种平衡化操作。
<ul>
<li>如果q的平衡因子为0，一个单旋转就可恢复p的平衡，由于旋转后被处理子树的高度没有缩短，所以置shorter的值为false。</li>
<li>如果q与p的平衡因子相同，一个单旋转就可恢复p的平衡。由于此时被处理子树的高度被缩短，故shorter的值仍为true。最后，结点p和q的平衡因子均改为0。</li>
<li>如果p与q的平衡因子的符号相反，则需要执行一个双旋转来恢复平衡，先围绕q转、再围绕p转。由于此时处理子树的高度被缩短，所以shorter的值仍为true，新的根结点的平衡因子置为0，其它结点的平衡因子作相应处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="B-树">B-树</h2>
<h3 id="m路查找树">m路查找树</h3>
<p>m路查找树是二叉排序树的一个推广，他修改了结点所含成员，一个m路查找树的结点至多含m棵子树和m-1个关键字。其中关键字的排序顺序也是从小到大的顺序。<br>
3路查找树例子<br>
<img src="/img/article_picture/3_road_search_tree.png"></p>
<h3 id="B-树-2">B-树</h3>
<ol>
<li>B-树就是一棵<strong>平衡的m路查找树</strong>。在B-树中我们引入“失败”结点，一个失败结点是当所查找的关键字不在树中时才能到达的结点。</li>
<li>B-树性质:</li>
</ol>
<ul>
<li>树中每个结点最多有m棵子树；</li>
<li>根结点至少有两棵子树；</li>
<li>除根结点之外的所有非叶子结点至少有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mrow><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil{m/2}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord mathnormal">m</span><span class="mord">/2</span></span><span class="mclose">⌉</span></span></span></span>棵子树；</li>
<li>所有失败结点出现在同一层上，失败结点为虚结点，在B-树中并不存在， 可视为查找失败时到达的结点，指向它们的指针为空指针。<br>
具体例子：<br>
<img src="/img/article_picture/B-tree.png"></li>
</ul>
<ol start="3">
<li>B-树查找性能分析<br>
B-树的查找时间与B-树的阶数m和B-树的高度h直接有关，必须加以权衡。</li>
</ol>
<h3 id="B-树的插入">B-树的插入</h3>
<p>在一棵m阶B-树中，每个非失败结点的关键字个数都在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><mo stretchy="false">⌈</mo><mrow><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（\lceil{m/2}\rceil-1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">（</span><span class="mopen">⌈</span><span class="mord"><span class="mord mathnormal">m</span><span class="mord">/2</span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><mi>m</mi><mo>−</mo><mn>1</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（m-1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span>之间。如果在关键字插入后结点中的关键字个数未超出上述范围的上界m-1，则可以直接插人；否则结点需要“分裂”。<br>
分裂原则：</p>
<ul>
<li>每一次插入结点一定是在叶子结点上插入，然后再看要不要分裂。具体实践可以看下图的例子<br>
<img src="/img/article_picture/B-tree_insert.png"></li>
</ul>
<h3 id="B-树的删除">B-树的删除</h3>
<p>B-树的删除总体上可以分为两种：删除根节点元素和删除叶子结点元素,其中删除叶子结点元素又分为四种。</p>
<h4 id="删除根节点元素">删除根节点元素</h4>
<p>删除根节点元素只要将该结点的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所指子树中的最小关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">P_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>所指子树中的最大关键字k）来代替被删关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">K_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后在k所在的叶结点中删除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>即可。</p>
<h4 id="删除叶子结点元素">删除叶子结点元素</h4>
<p>删除叶子结点元素分为四种情况</p>
<ul>
<li>被删关键字所在叶结点同时又是根结点且删除前该结点中关键字个数n≥2。<br>
<strong>处理方法：直接删去该关键字并将修改后的结点写回磁盘，删除结束。</strong></li>
<li>被删关键字所在叶结点不是根结点且删除前该结点中关键字个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">n≥\lceil m/2\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>。<br>
<strong>处理方法：直接删去该关键字并将修改后的结点写回磁盘，删除结束。</strong></li>
<li>被删关键字所在叶结点删除前关键字个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=\lceil m/2\rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，与该结点相邻的左(或右)兄弟结点的关键字个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">n≥\lceil m/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>。<br>
处理方法：
<ul>
<li>将其双亲结点中大于(或小于)该被删关键字的所有关键字最小（或最大）的一个关键字Ki下移到被删关键字所在结点中；</li>
<li>将左（或右）兄弟结点中的最大（或最小）关键字上移到双亲结点的ki位置；</li>
<li>将左（或右）兄弟结点中的最右(或最左)子树指针删除，并将结点中的关键字个数减1。<br>
实际图示可以看如下图：<br>
<img src="/img/article_picture/B-tree_delete3.png"></li>
</ul>
</li>
<li>被删关键字所在叶结点p删除前关键字个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=\lceil m/2 \rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，与该结点相邻的左、右兄弟结点中的关键字个数也都为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。<br>
处理方法：
<ul>
<li>将其双亲结点中大于(或小于)该被删关键字的所有关键字最小（或最大）的一个关键字Ki下移到被删关键字所在结点中；</li>
<li>将左（或右）兄弟结点中的最大（或最小）关键字上移到双亲结点的ki位置；</li>
<li>将左（或右）兄弟结点中的最右(或最左)子树指针删除，并将结点中的关键字个数减1。<br>
<img src="/img/article_picture/B-tree_delete4.png"></li>
</ul>
</li>
</ul>
<h3 id="B-树-3">B+树</h3>
<p>B+树可以看作是B-树的一种变形，在实现文件索引结构方面比B-树使用得更普遍。</p>
<ol>
<li>B+树定义</li>
</ol>
<ul>
<li>树中每个非叶结点最多有m棵子树；</li>
<li>根结点至少有2棵子树。除根结点外，其它的非叶结点至少有m/2棵子树；有n棵子树的非叶结点中含有n个关键字，且按由小到大的顺序排列。</li>
<li>所有的叶结点都处于同一层次上，包含了全部关键字及指向相应数据元素的指针，且叶结点本身按关键字从小到大顺序链接；</li>
<li>所有的非叶结点可以看成是索引部分，结点中关键字Ki与指向子树的指针Pi构成一个索引项（Ki、Pi）。其中Ki是Pi所指向的子树中最大（或最小）的关键字。</li>
</ul>
<ol start="2">
<li>
<p>B+树的查找<br>
B+树有两种查找方式，一种是对叶结点之间的链表进行顺序查找，另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。</p>
</li>
<li>
<p>B+树的插入<br>
B+树的插人仅在叶结点上进行。每插入一个关键字后都要判断结点中的子树棵数是否超出范围。当插人后结点中的子树棵数n&gt;m时，需要将叶结点分裂为两个结点，它们所包含的关键字个数分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mtext>和</mtext><mo stretchy="false">⌈</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil (m+1)/2 \rceil和\lceil (m+1)/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mord cjk_fallback">和</span><span class="mopen">⌈(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>。并且它们的双亲结点中应同时包含这两个结点的最大关键字和指向这两个结点指针。当根结点分裂时，因为它没有双亲结点，就必须创建新的双亲结点，作为树的新根。这样树的高度就增加一层了。B+树的建立可以从空树开始，通过不断插入关键字完成。</p>
</li>
<li>
<p>B+树的删除<br>
B+树的删除也仅在叶结点中进行。若在叶结点中删除一个关键字后，其关键字的个数仍然不少于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil m/2\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>，这属于简单删除，其上层索引可以不改变。如果在叶结点中删除一个关键字后，其关键字的个数小于结点关键字的个数的下限<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil m/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">m</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>，则必须做结点的调整或合并工作。</p>
</li>
</ol>
<h2 id="散列表">散列表</h2>
<p>散列法查找又称哈希法、杂凑法或关键字地址计算法等，相应的表称为哈希表。 这种方法的基本思想是：首先在元素的关键字k和元素的存储位置p之间建立一个对应关系H，使得p=H(k)，H称为<strong>散列函数</strong>。创建哈希表时，把关键字为k的元素直接存入地址为H(k)的单元；以后当查找关键字为k的元素时，再利用哈希函数计算出该元素的存储位置p=H(k)，从而达到按关键字直接存取元素的目的。(通过散列函数构建关键字与内存之间的关系)。</p>
<h3 id="如何构建散列函数">如何构建散列函数</h3>
<p>此处介绍一些常见的散列函数</p>
<ul>
<li>
<p>直接定址法</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>∗</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>+</mo><mi>c</mi><mtext>（其中</mtext><mi>a</mi><mtext>、</mtext><mi>c</mi><mtext>是整常数）</mtext></mrow><annotation encoding="application/x-tex">Hash(key) = a*key+c  （其中a、c是整常数）
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">c</span><span class="mord cjk_fallback">（其中</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">c</span><span class="mord cjk_fallback">是整常数）</span></span></span></span></span></p>
<p>优点：不会出现冲突<br>
缺点：散列地址空间的大小与关键字集合的大小相同(比较耗费空间)</p>
</li>
<li>
<p>数字分析法<br>
数字分析法就是根据散列表的大小，在关键字中选取某些分布均匀的若干位作为散列地址。<br>
计算均匀度公式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><mo stretchy="false">(</mo><msubsup><mi>a</mi><mi>k</mi><mi>i</mi></msubsup><mo>−</mo><mfrac><mi>n</mi><mi>r</mi></mfrac><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mspace linebreak="newline"></mspace><mi>k</mi><mo>=</mo><mn>1</mn><mtext>、</mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mtext>、</mtext><mi>d</mi></mrow><annotation encoding="application/x-tex">\lambda_k=\sum_{i=1}^r(a_k^i-\frac{n}{r})^2   \\   k=1、...、d 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord">...</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal">d</span></span></span></span></span></p>
</li>
<li>
<p>除留余数法</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mtext>（</mtext><mi>k</mi><mi>e</mi><mi>y</mi><mtext>）</mtext><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi mathvariant="normal">%</mi><mi>p</mi><mtext>（</mtext><mi>p</mi><mo>≤</mo><mi>m</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">Hash（key）=key\%p  （p≤m）
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9444em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">%</span><span class="mord mathnormal">p</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">）</span></span></span></span></span></p>
</li>
<li>
<p>乘余取整法</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mtext>（</mtext><mi>k</mi><mi>e</mi><mi>y</mi><mtext>）</mtext><mo>=</mo><mo stretchy="false">⌈</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>a</mi><mo>∗</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi mathvariant="normal">%</mi><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">Hash（key）=\lceil n*(a*key \% 1)\rceil
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mord">%1</span><span class="mclose">)⌉</span></span></span></span></span></p>
</li>
</ul>
<h3 id="避免冲突的方法">避免冲突的方法</h3>
<p>这里存在这一个问题：<strong>不同的关键字可以对应相同的哈希表</strong>，这就是<strong>冲突</strong>，冲突是无法避免的，只有通过改进哈希函数的性能才能减少冲突。<br>
处理冲突主要有闭散列和开散列两种方法</p>
<h4 id="闭散列">闭散列</h4>
<ol>
<li>闭散列的线性探索法<br>
当需要查找或加入一个元素时，使用散列函数计算以确定元素的桶号：h＝Hash(Key)。一旦发生冲突，则依次向后寻找“下一个”空桶Hi的公式为：</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mtext>＝</mtext><mo stretchy="false">(</mo><msub><mi>H</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>％</mtext><mi>m</mi><mtext>，</mtext><mi>i</mi><mtext>＝</mtext><mn>1</mn><mtext>，</mtext><mn>2</mn><mtext>，</mtext><mo>…</mo><mtext>，</mtext><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">H_i＝(H_{i-1}+1)％m，i＝1，2，…，m-1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">％</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">＝</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>直至找到空的位置。<br>
缺点：线性探测方法容易产生“<strong>堆积(clusters)</strong>”的问题，即数据元素集中占据了数据表的某一区域，使得为寻找某一数据元素需要的查找时间增加。<br>
<strong>注意事项：闭散列是不可以直接删去点的，会导致其他元素的查找错误，所以只能设置一个删除标记（浪费空间）</strong><br>
2. 二次探索法</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mtext>＝</mtext><mo stretchy="false">(</mo><msub><mi>H</mi><mn>0</mn></msub><mo>+</mo><mi>d</mi><mi>i</mi><mo stretchy="false">)</mo><mtext>％</mtext><mi>m</mi><mtext>，</mtext><msub><mi>d</mi><mi>i</mi></msub><mtext>＝</mtext><msup><mn>1</mn><mn>2</mn></msup><mtext>，</mtext><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mtext>，</mtext><msup><mn>2</mn><mn>2</mn></msup><mtext>，</mtext><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mtext>，</mtext><mo>…</mo><mtext>（</mtext><mi>i</mi><mtext>＝</mtext><mn>1</mn><mtext>，</mtext><mn>2</mn><mtext>，</mtext><mo>…</mo><mtext>，</mtext><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>／</mtext><mn>2</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">   H_i＝(H_0+di)％m，d_i＝1^2，-1^2，2^2，-2^2，…
（i＝1，2，…，(m-1)／2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mord cjk_fallback">％</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">＝</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">／</span><span class="mord">2</span><span class="mord cjk_fallback">）</span></span></span></span></span></p>
<pre><code>二次探索和线性探索相比结点间隔更远一些。
</code></pre>
<ol start="3">
<li>双散列法<br>
两个散列表，发生冲突了使用另一个散列表rehsah。</li>
</ol>
<h4 id="开散列">开散列</h4>
<p>闭散列的每一个桶只能含有一个元素，而开散列的每一个同可以含有多个元素，只要通过链式结构就可以实现多元素存储。实例如下：<br>
<img src="/img/article_picture/open_hash.png"></p>
<p>对于一系列冲突解决方法的比较<br>
<img src="/img/article_picture/conflit-solution-compare.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xlj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/05/16/%E6%9F%A5%E6%89%BE/">http://example.com/2022/05/16/%E6%9F%A5%E6%89%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">xljのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/article_picture1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/03/27/BERT%E6%A8%A1%E5%9E%8BMRCP%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"><img class="next-cover" src="/img/article_picture3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BERT模型MRCP任务实践</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xlj</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxxlj" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到 xlj's blog！本博客基于阿里云服务器+hexo框架+butterfly主题搭建，主要用于记录自己的学习与生活。网页初步上线，暂时只有几篇文章，后续会增加包括计算机课内外学习、论文阅读、娱乐生活等内容。同时，欢迎大家来添加友链，共同进步。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.</span> <span class="toc-text">顺序表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">顺序查找：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.2.</span> <span class="toc-text">有序表的折半查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E5%80%92%E6%8E%92%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.</span> <span class="toc-text">索引顺序表和倒排表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">索引顺序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">倒排索引表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.2.</span> <span class="toc-text">二叉排序树的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.4.3.</span> <span class="toc-text">二叉排序树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.4.</span> <span class="toc-text">二叉排序树的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.4.5.</span> <span class="toc-text">二叉排序树查找性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">平衡二叉树的定义和概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC"><span class="toc-number">1.5.2.</span> <span class="toc-text">&#x3D;&#x3D;平衡旋转&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LL%E6%97%8B%E8%BD%AC"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">LL旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR%E6%97%8B%E8%BD%AC"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">RR旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR%E6%97%8B%E8%BD%AC"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">LR旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RL%E6%97%8B%E8%BD%AC"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">RL旋转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.3.</span> <span class="toc-text">平衡二叉树的插入删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">&#x3D;&#x3D;删除&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">1.6.</span> <span class="toc-text">B-树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#m%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">1.6.1.</span> <span class="toc-text">m路查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91-2"><span class="toc-number">1.6.2.</span> <span class="toc-text">B-树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.6.3.</span> <span class="toc-text">B-树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.4.</span> <span class="toc-text">B-树的删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%A0%B9%E8%8A%82%E7%82%B9%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">删除根节点元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">删除叶子结点元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91-3"><span class="toc-number">1.6.5.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">如何构建散列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">避免冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E6%95%A3%E5%88%97"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">闭散列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%95%A3%E5%88%97"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">开散列</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/16/%E6%9F%A5%E6%89%BE/" title="查找"><img src="/img/article_picture1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="查找"/></a><div class="content"><a class="title" href="/2022/05/16/%E6%9F%A5%E6%89%BE/" title="查找">查找</a><time datetime="2022-05-15T16:00:00.000Z" title="发表于 2022-05-16 00:00:00">2022-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/27/BERT%E6%A8%A1%E5%9E%8BMRCP%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/" title="BERT模型MRCP任务实践"><img src="/img/article_picture3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BERT模型MRCP任务实践"/></a><div class="content"><a class="title" href="/2022/03/27/BERT%E6%A8%A1%E5%9E%8BMRCP%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/" title="BERT模型MRCP任务实践">BERT模型MRCP任务实践</a><time datetime="2022-03-26T16:00:00.000Z" title="发表于 2022-03-27 00:00:00">2022-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/27/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/" title="树和森林"><img src="/img/article_picture4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树和森林"/></a><div class="content"><a class="title" href="/2022/03/27/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/" title="树和森林">树和森林</a><time datetime="2022-03-26T16:00:00.000Z" title="发表于 2022-03-27 00:00:00">2022-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/14/BERT/" title="BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding"><img src="/img/article_picture/BERT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding"/></a><div class="content"><a class="title" href="/2022/03/14/BERT/" title="BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a><time datetime="2022-03-13T16:00:00.000Z" title="发表于 2022-03-14 00:00:00">2022-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/08/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树"><img src="/img/article_picture1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二叉树"/></a><div class="content"><a class="title" href="/2022/03/08/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">二叉树</a><time datetime="2022-03-07T16:00:00.000Z" title="发表于 2022-03-08 00:00:00">2022-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/07/Transformer/" title="Attention is all you need"><img src="/img/article_picture/transformer.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Attention is all you need"/></a><div class="content"><a class="title" href="/2022/03/07/Transformer/" title="Attention is all you need">Attention is all you need</a><time datetime="2022-03-06T16:00:00.000Z" title="发表于 2022-03-07 00:00:00">2022-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/02/%E5%9B%BE/" title="图"><img src="/img/article_picture1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图"/></a><div class="content"><a class="title" href="/2022/03/02/%E5%9B%BE/" title="图">图</a><time datetime="2022-03-01T16:00:00.000Z" title="发表于 2022-03-02 00:00:00">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/02/%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="广义表"><img src="/img/article_picture3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="广义表"/></a><div class="content"><a class="title" href="/2022/03/02/%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="广义表">广义表</a><time datetime="2022-03-01T16:00:00.000Z" title="发表于 2022-03-02 00:00:00">2022-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/%E6%95%B0%E7%BB%84/" title="数组"><img src="/img/article_picture.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数组"/></a><div class="content"><a class="title" href="/2022/03/01/%E6%95%B0%E7%BB%84/" title="数组">数组</a><time datetime="2022-02-28T16:00:00.000Z" title="发表于 2022-03-01 00:00:00">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/28/%E4%B8%B2/" title="串"><img src="/img/article_picture5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="串"/></a><div class="content"><a class="title" href="/2022/02/28/%E4%B8%B2/" title="串">串</a><time datetime="2022-02-27T16:00:00.000Z" title="发表于 2022-02-28 00:00:00">2022-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/25/%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE%E7%94%B3%E8%AF%B7%E4%B9%A6/" title="创新创业申请书"><img src="/img/article_picture4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创新创业申请书"/></a><div class="content"><a class="title" href="/2022/02/25/%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE%E7%94%B3%E8%AF%B7%E4%B9%A6/" title="创新创业申请书">创新创业申请书</a><time datetime="2022-02-24T16:00:00.000Z" title="发表于 2022-02-25 00:00:00">2022-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/24/openmpi/" title="NFS+MPICH"><img src="/img/article_picture3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NFS+MPICH"/></a><div class="content"><a class="title" href="/2022/02/24/openmpi/" title="NFS+MPICH">NFS+MPICH</a><time datetime="2022-02-24T13:01:00.000Z" title="发表于 2022-02-24 21:01:00">2022-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/16/%E9%98%9F%E5%88%97/" title="队列"><img src="/img/article_picture1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="队列"/></a><div class="content"><a class="title" href="/2022/02/16/%E9%98%9F%E5%88%97/" title="队列">队列</a><time datetime="2022-02-16T06:41:47.000Z" title="发表于 2022-02-16 14:41:47">2022-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/16/%E6%A0%88/" title="栈"><img src="/img/article_picture2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈"/></a><div class="content"><a class="title" href="/2022/02/16/%E6%A0%88/" title="栈">栈</a><time datetime="2022-02-16T06:26:03.000Z" title="发表于 2022-02-16 14:26:03">2022-02-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: grey"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xlj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">本网站旨在记录自己的学习与经历，欢迎大家浏览。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>